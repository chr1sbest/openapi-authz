package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
	"strings"

	"github.com/chr1sbest/openapi-authz/internal/model"
)

// Generate produces Go source code that defines RouteKey, AuthPolicy and a
// Policies map initialized with the contents of cfg.
func Generate(pkg string, cfg *model.Config) ([]byte, error) {
	var buf bytes.Buffer

	fmt.Fprintf(&buf, "// Code generated by openapi-authz; DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "package %s\n\n", pkg)

	buf.WriteString("type RouteKey struct {\n")
	buf.WriteString("\tMethod string\n")
	buf.WriteString("\tPath   string\n")
	buf.WriteString("}\n\n")

	buf.WriteString("type AuthPolicy struct {\n")
	buf.WriteString("\tRequireAuth bool\n")
	buf.WriteString("\tRoles       []string\n")
	buf.WriteString("\tScopes      []string\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// Policies is derived from OpenAPI security requirements; see openapi-authz docs.\n")
	buf.WriteString("var Policies = map[RouteKey]AuthPolicy{\n")

	// Sort keys for deterministic output.
	keys := make([]model.RouteKey, 0, len(cfg.Policies))
	for k := range cfg.Policies {
		keys = append(keys, k)
	}
	sort.Slice(keys, func(i, j int) bool {
		if keys[i].Path == keys[j].Path {
			return keys[i].Method < keys[j].Method
		}
		return keys[i].Path < keys[j].Path
	})

	for _, k := range keys {
		p := cfg.Policies[k]
		fmt.Fprintf(&buf, "\t{Method: %q, Path: %q}: {RequireAuth: %t", k.Method, k.Path, p.RequireAuth)

		if len(p.Roles) > 0 {
			fmt.Fprintf(&buf, ", Roles: []string{%s}", quoteList(p.Roles))
		}
		if len(p.Scopes) > 0 {
			fmt.Fprintf(&buf, ", Scopes: []string{%s}", quoteList(p.Scopes))
		}

		buf.WriteString("},\n")
	}

	buf.WriteString("}\n")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("format generated code: %w", err)
	}
	return formatted, nil
}

func quoteList(items []string) string {
	parts := make([]string, len(items))
	for i, s := range items {
		parts[i] = fmt.Sprintf("%q", s)
	}
	return strings.Join(parts, ", ")
}
